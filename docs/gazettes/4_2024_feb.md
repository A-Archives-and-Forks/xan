# Xan Gazette: February 2024 Edition

First thing first: our fork of `xsv` is now officially named `xan` and is published on [crates.io](https://crates.io/) as a fully-fledged `rust` crate.

This means installing our fork is now as simple as:

```bash
cargo install xan
```

This also mean we will need to rewire our muscle memory to type `xan` or add a fancy bash alias.

Also, the expression language used by the CLI has also changed name from `xan` to `moonblade` which is Xan's fire sword from Baldur's Gate 1. So emo!

![moonblade](https://static.wikia.nocookie.net/baldursgategame/images/1/1a/Moonblade.png/revision/latest?cb=20121222222319)

## Summary

* [Sleeker flatten command](#sleeker-flatten-command)
* [Using pest to define moonblade grammar](#using-pest-to-define-moonblade-grammar)
* [Changing moonblade semantics regarding column indexing](#changing-moonblade-semantics-regarding-column-indexing)
* [Infix operators for moonblade](#infix-operators-for-moonblade)
* [The agg and groupby commands](#the-agg-and-groupby-commands)
* [New moonblade functions](#new-moonblade-functions)
* [Various fixes](#various-fixes)

### Sleeker flatten command

The `flatten` command has been revamped visually to match the visuals of the `view` command:

![sleeker-view](./img/sleeker-flatten.png)

### Using pest to define moonblade grammar

Before this `xan` release, `moonblade` expressions were parsed using the [`nom`](https://docs.rs/nom/latest/nom/) rust library.

It was fine and was a good way to learn about parser combinators, but I found easier to switch to [`pest`](https://pest.rs/) (a [PEG](https://en.wikipedia.org/wiki/Parsing_expression_grammar)-based library) to implement [infix operators](#infix-operators-for-moonblade).

The `moonblade` expression language now has a fully-fledged grammar that anyone can read [here](https://github.com/medialab/xan/blob/master/src/moonblade/grammar.pest).

### Changing moonblade semantics regarding column indexing

Unescaped column identifiers in the language cannot use space characters anymore. It was putting too much pression on the implementation and was preventing `moonblade` from going forward. This means you cannot write `trim(NOM DU CANDIDAT)` anymore.

What's more, there is no more `row["name", 1]` clunky parser exception. Now column indexing for names that must be escaped or for zero-based access or for duplicate column access must use the `col` function likewise:

```js
// Simple identifier
trim(name)

// Zero-based access
col(3)

// Name that must be escaped
col("NOM DU CANDIDAT")

// Duplicate headers
col("name", 2)
```

*Implementation details*

When the arguments of the `col` function are statically analyzable (e.g. when they are string literals or integer literals), the function "disappear" when the expression is parsed and are immediately replaced by the index of the corresponding column as per a file's headers.

This also mean that column indexing **can** be dynamic if needed, e.g. if the name of the column to read is to be given by another column's value:

```js
col(column_containing_relevant_count * 10)
```

### Infix operators for moonblade

I blame @robindemourat & @boogheta for this (they don't seem to like [Polish notation](https://en.wikipedia.org/wiki/Polish_notation)).

This means the `moonblade` expression language now has infix operators.

```js
add(A, B)
// becomes
A + B
// wow. incredible.
```

Infix operators are well known and this should make `moonblade` expressions more familiar and easier to read & write.

I just did not do it at the time because it is actually hard to do. Parsing Polish notation is very easy in comparison. I therefore had to implement an [operator-precedence parser](https://en.wikipedia.org/wiki/Operator-precedence_parser) and this was a nightmarish endeavor (for the record, `moonblade` currently uses what is called Pratt parsing to solve operator precedence and infix notation that are converted back into Polish notation).

Here is the list of operators currently implemented:

```md
### Unary operators

    !x - boolean negation
    -x - numerical negation,

### Numerical comparison

Warning: those operators will always consider operands as numbers and will
try to cast them around as such. For string/sequence comparison, use the
operators in the next section.

    x == y - numerical equality
    x != y - numerical inequality
    x <  y - numerical less than
    x <= y - numerical less than or equal
    x >  y - numerical greater than
    x >= y - numerical greater than or equal

### String/sequence comparison

Warning: those operators will always consider operands as strings or
sequences and will try to cast them around as such. For numerical comparison,
use the operators in the previous section.

    x eq y - string equality
    x ne y - string inequality
    x lt y - string less than
    x le y - string less than or equal
    x gt y - string greater than
    x ge y - string greater than or equal

### Arithmetic operators

    x + y  - numerical addition
    x - y  - numerical subtraction
    x * y  - numerical multiplication
    x / y  - numerical division
    x % y  - numerical remainder

    x // y - numerical integer division
    x ** y - numerical exponentiation

## String operators

    x . y - string concatenation

## Logical operators

    x &&  y - logical and
    x and y
    x ||  y - logical or
    x or  y

    x in y
    x not in y
```

*Some design notes*

Since CSV values are represented as strings (before you parse them, because you might want them as numbers, for instance) I chose to design `moonblade` operators to distinguish between numerical values and strings.

Else you would need to force users to explicitly parse values into numbers before being able to do anything with them and this felt tedious.

```js
// This means you can do:
x == y
// Instead of needing to do:
int(x) == int(y)
// But this also mean you need to do:
x eq y
// if you want to compare strings
```

`moonblade` operator design is therefore very close to `perl`, in that you have two distinct operators for equality (`==` for numbers and `eq` for strings/sequences), for instance.

You also have two different operators for addition (`+`) and string concatenation (`.`).

### The `agg` and `groupby` commands

After `map`, `filter`, `flatmap` & `transform`, `xan` introduces 2 new commands relying on `moonblade` expressions:

1. the `agg` command, able to run an aggregation over a CSV file
2. the `groupby` command, able to run similar aggregations over groups of rows of a CSV files, defined by having a same value of a specific column.

In a sense, `agg` is a generic version of the `stats` command, whereas `groupby` is a generic version of the `frequency` command.

They both rely on evaluating an aggregation expression that are very reminiscent of SQL `GROUP BY` clauses and aggregation functions.

You can, for instance, compute the sum of a column:

```bash
xan agg 'sum(retweet_count)' file.csv
```

You can use dynamic expressions to mangle the data before aggregating it:

```bash
xan agg 'sum(retweet_count + replies_count)' file.csv
```

You can perform multiple aggregations at once:

```bash
xan agg 'sum(retweet_count), mean(retweet_count), max(replies_count)' file.csv
```

You can rename the output columns using the 'as' syntax:

```bash
xan agg 'sum(n) as sum, max(replies_count) as "Max Replies"' file.csv
```

Then using the `groupby` command is just a matter of indicating a column that will be used to group rows:

```bash
xan groupby thread_id 'count() as tweets_per_thread' file.csv
```

Here is the list of currently supported aggregation functions:

* `all`
* `any`
* `cardinality`
* `count`
* `first`
* `last`
* `lex_first`
* `lex_last`
* `max`
* `min`
* `mean` (`avg`)
* `median`
* `median_high`
* `median_low`
* `mode`
* `stddev` (`stddev_pop`)
* `stddev_sample`
* `sum`
* `var` (`var_pop`)
* `var_sample`

*Design notes*

Once again, since CSV values are represented as strings (before you parse them, because you might want them as numbers, for instance), I had to make some design choices that are different from the ones SQL implementation usually make.

What I mean is that in SQL databases, we know the type of the variables stored by the columns, which means you don't have to have distinct aggregation function for the min & max of numerical columns or string columns.

But with CSV data, what do you mean when you ask for the minimum of a column that can contain numbers and/or strings? Do you want the minimum numerical value? Do you want to fallback to the first string in lexicographic order as soon as we encounter a string that cannot be parsed as a number?

I chose to be explicit, which is why you get both a `min/max` function and a `lex_first/lex_last` which both encompass a choice about the way you want to consider processed values.

### New moonblade functions

*`count` now accepts regex patterns*

```js
count(text, /mr\.\b/i)
```

*`filesize` gives you the size of a file at some path in bytes*

```js
filesize(path)
```

*`neg` gives you numerical negation*

```js
neg(-1) == 1
```

*`fmt` lets you format strings easily*

```js
fmt("{} {}, age: {}", name, surname, age)
```

*`log` gives you natural logarithms*

```js
log(occurrences)
```

*`pow` gives you exponentiation*

```js
pow(count, 2)
```

*`escape_regex` lets you escape strings for regex*

```js
escape_regex("N.A.T.O.")
```

This is very useful to compose regex patterns using the `map` or `transform` command before feeding them to `search --input` or `join --regex`.

*`md5` lets you hash arbitrary strings*

```js
md5(read(path))
```

This can be used to pseudonymize a column, e.g.:

```bash
xsv transform name 'md5' file.csv > pseudonimyzed.csv
```

### Various fixes

* The [Freedman-Diaconis](https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule) rule used to automatically choose the number of bins use by the `bins` command has been fixed.
* Some `moonblade` functions have been optimized. Won't say much about this but basically when we keep ownership of the processed values we are able to mutate them to avoid further allocation.